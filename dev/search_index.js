var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#Base","page":"API","title":"Base","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"AbstractTrees.ImplicitParents\nAbstractTrees.ImplicitSiblings\nAbstractTrees.ParentLinks\nAbstractTrees.SiblingLinks\nAbstractTrees.StoredParents\nAbstractTrees.StoredSiblings\nchildren\nintree\nischild\nisdescendant\nAbstractTrees.nodetype\nAbstractTrees.parentlinks\nAbstractTrees.siblinglinks\ntreebreadth\ntreeheight\ntreemap\ntreemap!\ntreesize","category":"page"},{"location":"api/#AbstractTrees.StoredParents","page":"API","title":"AbstractTrees.StoredParents","text":"Indicates that this tree stores parent links explicitly. The implementation   is responsible for defining the parentind function to expose this   information.\n\n\n\n\n\n","category":"type"},{"location":"api/#AbstractTrees.StoredSiblings","page":"API","title":"AbstractTrees.StoredSiblings","text":"Indicates that this tree stores sibling links explicitly, or can compute them   quickly (e.g. because the tree has a (small) fixed branching ratio, so the   current index of a node can be determined by quick linear search). The   implementation is responsible for defining the relative_state function   to expose this information.\n\n\n\n\n\n","category":"type"},{"location":"api/#AbstractTrees.children","page":"API","title":"AbstractTrees.children","text":"children(node)\n\nGet the immediate children of node.\n\nThis is the primary function that needs to be implemented for custom tree types. It should return an iterable object for which an appropriate implementation of Base.pairs is available.\n\nThe default behavior is to assume that if an object is iterable, iterating over it gives its children. Non-iterable types are treated as leaf nodes.\n\n\n\n\n\n","category":"function"},{"location":"api/#AbstractTrees.intree","page":"API","title":"AbstractTrees.intree","text":"intree(node, root)\n\nCheck if node is a member of the tree rooted at root.\n\nBy default this traverses through the entire tree in search of node, and so may be slow if a more specialized method has not been implemented for the given tree type.\n\nSee also: isdescendant\n\n\n\n\n\n","category":"function"},{"location":"api/#AbstractTrees.ischild","page":"API","title":"AbstractTrees.ischild","text":"ischild(node1, node2)\n\nCheck if node1 is a child of node2.\n\nBy default this iterates through children(node2), so performance may be improved by adding a specialized method for given node type.\n\n\n\n\n\n","category":"function"},{"location":"api/#AbstractTrees.isdescendant","page":"API","title":"AbstractTrees.isdescendant","text":"isdescendant(node1, node2)\n\nCheck if node1 is a descendant of node2. This isequivalent to checking whether node1 is a member of the subtree rooted at node2 (see intree) except that a node cannot be a descendant of itself.\n\nInternally this calls intree(node1, node2) and so may be slow if a specialized method of that function is not available.\n\n\n\n\n\n","category":"function"},{"location":"api/#AbstractTrees.nodetype","page":"API","title":"AbstractTrees.nodetype","text":"nodetype(tree)\n\nA trait function, defined on the tree object, specifying the types of the nodes. The default is Any. When applicable, define this trait to make iteration inferrable.\n\nExample\n\nstruct IntTree\n    num::Int\n    children::Vector{IntTree}\nend\nAbstractTrees.children(itree::IntTree) = itree.children\nAbstractTrees.nodetype(::IntTree) = IntTree\n\nThis suffices to make iteration over, e.g., Leaves(itree::IntTree) inferrable.\n\n\n\n\n\n","category":"function"},{"location":"api/#AbstractTrees.treebreadth","page":"API","title":"AbstractTrees.treebreadth","text":"treebreadth(node)\n\nGet the number of leaves in the tree rooted at node. Leaf nodes have a breadth of one.\n\nBy default this recurses through all nodes in the tree and so may be slow if a more specialized method has not been implemented for the given type.\n\n\n\n\n\n","category":"function"},{"location":"api/#AbstractTrees.treeheight","page":"API","title":"AbstractTrees.treeheight","text":"treeheight(node)\n\nGet the maximum depth from node to any of its descendants. Leaf nodes have a height of zero.\n\nBy default this recurses through all nodes in the tree and so may be slow if a more specialized method has not been implemented for the given type.\n\n\n\n\n\n","category":"function"},{"location":"api/#AbstractTrees.treesize","page":"API","title":"AbstractTrees.treesize","text":"treesize(node)\n\nGet the size of the tree rooted at node.\n\nBy default this recurses through all nodes in the tree and so may be slow if a more specialized method has not been implemented for the given type.\n\n\n\n\n\n","category":"function"},{"location":"api/#Printing","page":"API","title":"Printing","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"AbstractTrees.DEFAULT_CHARSET\nAbstractTrees.ASCII_CHARSET\nAbstractTrees.TreeCharSet\nprint_tree\nAbstractTrees.print_child_key\nAbstractTrees.printkeys_default\nAbstractTrees.printnode\nAbstractTrees.repr_node\nAbstractTrees.repr_tree","category":"page"},{"location":"api/#AbstractTrees.DEFAULT_CHARSET","page":"API","title":"AbstractTrees.DEFAULT_CHARSET","text":"Default charset argument used by print_tree.\n\n\n\n\n\n","category":"constant"},{"location":"api/#AbstractTrees.ASCII_CHARSET","page":"API","title":"AbstractTrees.ASCII_CHARSET","text":"Charset using only ASCII characters.\n\n\n\n\n\n","category":"constant"},{"location":"api/#AbstractTrees.TreeCharSet","page":"API","title":"AbstractTrees.TreeCharSet","text":"TreeCharSet(mid, terminator, skip, dash, trunc, pair)\n\nSet of characters (or strings) used to pretty-print tree branches in print_tree.\n\nFields\n\nmid::String - \"Forked\" branch segment connecting to middle children.\nterminator::String - Final branch segment connecting to last child.\nskip::String - Vertical branch segment.\ndash::String - Horizontal branch segmentt printed to the right of mid and terminator.\ntrunc::String - Used to indicate the subtree has been truncated at the maximum depth.\npair::String - Printed between a child node and its key.\n\n\n\n\n\n","category":"type"},{"location":"api/#AbstractTrees.print_tree","page":"API","title":"AbstractTrees.print_tree","text":"print_tree(tree; kwargs...)\nprint_tree(io::IO, tree; kwargs...)\nprint_tree(f::Function, io::IO, tree; kwargs...)\n\nPrint a text representation of tree to the given io object.\n\nArguments\n\nf::Function - custom implementation of printnode to use. Should have the signature f(io::IO, node).\nio::IO - IO stream to write to.\ntree - tree to print.\nmaxdepth::Integer = 5 - truncate printing of subtrees at this depth.\nindicate_truncation::Bool = true - print a vertical ellipsis character beneath truncated nodes.\ncharset::TreeCharSet - TreeCharSet to use to print branches.\nprintkeys::Union{Bool, Nothing} - Whether to print keys of child nodes (using pairs(children(node))). A value of nothing uses printkeys_default do decide the behavior on a node-by-node basis.\n\nExamples\n\njulia> tree = [1:3, \"foo\", [[[4, 5], 6, 7], 8]];\n\njulia> print_tree(tree)\nVector{Any}\n├─ UnitRange{Int64}\n│  ├─ 1\n│  ├─ 2\n│  └─ 3\n├─ \"foo\"\n└─ Vector{Any}\n   ├─ Vector{Any}\n   │  ├─ Vector{Int64}\n   │  │  ├─ 4\n   │  │  └─ 5\n   │  ├─ 6\n   │  └─ 7\n   └─ 8\n\njulia> print_tree(tree, maxdepth=2)\nVector{Any}\n├─ UnitRange{Int64}\n│  ├─ 1\n│  ├─ 2\n│  └─ 3\n├─ \"foo\"\n└─ Vector{Any}\n   ├─ Vector{Any}\n   │  ⋮\n   │\n   └─ 8\n\njulia> print_tree(tree, charset=AbstractTrees.ASCII_CHARSET)\nVector{Any}\n+-- UnitRange{Int64}\n|   +-- 1\n|   +-- 2\n|   \\-- 3\n+-- \"foo\"\n\\-- Vector{Any}\n    +-- Vector{Any}\n    |   +-- Vector{Int64}\n    |   |   +-- 4\n    |   |   \\-- 5\n    |   +-- 6\n    |   \\-- 7\n    \\-- 8\n\n\n\n\n\n","category":"function"},{"location":"api/#AbstractTrees.print_child_key","page":"API","title":"AbstractTrees.print_child_key","text":"print_child_key(io::IO, key)\n\nPrint the key for a child node.\n\n\n\n\n\n","category":"function"},{"location":"api/#AbstractTrees.printkeys_default","page":"API","title":"AbstractTrees.printkeys_default","text":"printkeys_default(children)::Bool\n\nWhether a collection of children should be printed with its keys by default.\n\nThe base behavior is to print keys for all collections for which keys() is defined, with the exception of AbstractVectors and tuples.\n\n\n\n\n\n","category":"function"},{"location":"api/#AbstractTrees.printnode","page":"API","title":"AbstractTrees.printnode","text":"printnode(io::IO, node)\n\nPrint a compact representation of a single node.\n\n\n\n\n\n","category":"function"},{"location":"api/#AbstractTrees.repr_node","page":"API","title":"AbstractTrees.repr_node","text":"repr_node(node; context=nothing)\n\nGet the string representation of a node using printnode. This works analagously to Base.repr.\n\ncontext is an IO or IOContext object whose attributes are used for the I/O stream passed to printnode.\n\n\n\n\n\n","category":"function"},{"location":"api/#AbstractTrees.repr_tree","page":"API","title":"AbstractTrees.repr_tree","text":"repr_tree(tree; context=nothing, kw...)\n\nGet the string result of calling print_tree with the supplied arguments.\n\nThe context argument works as it does in Base.repr.\n\n\n\n\n\n","category":"function"},{"location":"api/#Iteration","page":"API","title":"Iteration","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Leaves\nPostOrderDFS\nPreOrderDFS\nStatelessBFS\nTreeIterator","category":"page"},{"location":"api/#AbstractTrees.Leaves","page":"API","title":"AbstractTrees.Leaves","text":"Iterator to visit the leaves of a tree, e.g. for the tree\n\nAny[1,Any[2,3]]\n├─ 1\n└─ Any[2,3]\n   ├─ 2\n   └─ 3\n\nwe will get [1,2,3].\n\n\n\n\n\n","category":"type"},{"location":"api/#AbstractTrees.PostOrderDFS","page":"API","title":"AbstractTrees.PostOrderDFS","text":"Iterator to visit the nodes of a tree, guaranteeing that children will be visited before their parents.\n\ne.g. for the tree\n\nAny[1,Any[2,3]]\n├─ 1\n└─ Any[2,3]\n   ├─ 2\n   └─ 3\n\nwe will get [1, 2, 3, [2, 3], [1, [2, 3]]].\n\n\n\n\n\n","category":"type"},{"location":"api/#AbstractTrees.PreOrderDFS","page":"API","title":"AbstractTrees.PreOrderDFS","text":"Iterator to visit the nodes of a tree, guaranteeing that parents will be visited before their children.\n\nOptionally takes a filter function that determines whether the iterator should continue iterating over a node's children (if it has any) or should consider that node a leaf.\n\ne.g. for the tree\n\nAny[Any[1,2],Any[3,4]]\n├─ Any[1,2]\n|  ├─ 1\n|  └─ 2\n└─ Any[3,4]\n   ├─ 3\n   └─ 4\n\nwe will get [[[1, 2], [3, 4]], [1, 2], 1, 2, [3, 4], 3, 4].\n\nInvalidation\n\nModifying the underlying tree while iterating over it, is allowed, however, if parents and sibling links are not explicitly stored, the identity of any parent of the last obtained node does not change (i.e. mutation is allowed, replacing nodes is not).\n\n\n\n\n\n","category":"type"},{"location":"api/#AbstractTrees.StatelessBFS","page":"API","title":"AbstractTrees.StatelessBFS","text":"Iterator to visit the nodes of a tree, all nodes of a level will be visited before their children\n\ne.g. for the tree\n\nAny[1,Any[2,3]]\n├─ 1\n└─ Any[2,3]\n   ├─ 2\n   └─ 3\n\nwe will get [[1, [2,3]], 1, [2, 3], 2, 3].\n\nWARNING: This is O(n^2), only use this if you know you need it, as opposed to a more standard statefull approach.\n\n\n\n\n\n","category":"type"},{"location":"api/#Other","page":"API","title":"Other","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"AnnotationNode\nShadowTree\nTree","category":"page"},{"location":"implementing/#Implementing-the-AbstractTrees-API","page":"Implementing the AbstractTrees API","title":"Implementing the AbstractTrees API","text":"","category":"section"},{"location":"implementing/","page":"Implementing the AbstractTrees API","title":"Implementing the AbstractTrees API","text":"Consider the following custom node type, which stores a single data value along with an explicit list of child nodes:","category":"page"},{"location":"implementing/","page":"Implementing the AbstractTrees API","title":"Implementing the AbstractTrees API","text":"struct MyNode{T}\n    data::T\n    children::Vector{MyNode{T}}\nend\n\nMyNode(data::T, children=MyNode{T}[]) where T = MyNode{T}(data, children)","category":"page"},{"location":"implementing/","page":"Implementing the AbstractTrees API","title":"Implementing the AbstractTrees API","text":"All that is needed to implement the AbstractTrees interface for MyNode is to define the appropriate method of children:","category":"page"},{"location":"implementing/","page":"Implementing the AbstractTrees API","title":"Implementing the AbstractTrees API","text":"using AbstractTrees\n\nAbstractTrees.children(node::MyNode) = node.children\n\n# output","category":"page"},{"location":"implementing/","page":"Implementing the AbstractTrees API","title":"Implementing the AbstractTrees API","text":"This is sufficient to enable most of the functionality of this package, such as basic printing and tree traversal:","category":"page"},{"location":"implementing/","page":"Implementing the AbstractTrees API","title":"Implementing the AbstractTrees API","text":"tree = MyNode(1, [\n    MyNode(2, [\n        MyNode(3),\n        MyNode(4),\n    ]),\n    MyNode(5),\n    MyNode(6, [\n        MyNode(7),\n    ]),\n])\n\n[node.data for node in PostOrderDFS(tree)]\n\n# output\n\n7-element Vector{Int64}:\n 3\n 4\n 2\n 5\n 7\n 6\n 1","category":"page"},{"location":"implementing/#Optional-functions","page":"Implementing the AbstractTrees API","title":"Optional functions","text":"","category":"section"},{"location":"implementing/","page":"Implementing the AbstractTrees API","title":"Implementing the AbstractTrees API","text":"These functions have default implementations that depend only on the output of children, but may have suboptimal performance that can be improved by adding a custom method for your type.","category":"page"},{"location":"implementing/#children-related-functions","page":"Implementing the AbstractTrees API","title":"children-related functions","text":"","category":"section"},{"location":"implementing/","page":"Implementing the AbstractTrees API","title":"Implementing the AbstractTrees API","text":"If the children method for your type involves a non-trivial amount of computation (e.g. if the returned child objects need to be created with each call instead of being explicitly stored in the parent as in the example above) providing your own implementation of these functions may significantly reduce overhead:","category":"page"},{"location":"implementing/","page":"Implementing the AbstractTrees API","title":"Implementing the AbstractTrees API","text":"ischild","category":"page"},{"location":"implementing/#Subtree-related","page":"Implementing the AbstractTrees API","title":"Subtree-related","text":"","category":"section"},{"location":"implementing/","page":"Implementing the AbstractTrees API","title":"Implementing the AbstractTrees API","text":"The following functions recurse through a node's entire subtree by default, which should be avoided if possible:","category":"page"},{"location":"implementing/","page":"Implementing the AbstractTrees API","title":"Implementing the AbstractTrees API","text":"intree\nisdescendant\ntreebreadth\ntreesize\ntreeheight","category":"page"},{"location":"implementing/#Type-traits","page":"Implementing the AbstractTrees API","title":"Type traits","text":"","category":"section"},{"location":"implementing/","page":"Implementing the AbstractTrees API","title":"Implementing the AbstractTrees API","text":"AbstractTrees.nodetype(tree) can be defined to make iteration inferable.\nAbstractTrees.ParentLinks can be defined to return AbstractTrees.StoredParents() if a tree type stores explicit links to a parent; AbstractTrees.SiblingLinks, when set to AbstractTrees.StoredSiblings(), serves the same role for siblings. See their docstrings for more information.","category":"page"},{"location":"implementing/#Printing","page":"Implementing the AbstractTrees API","title":"Printing","text":"","category":"section"},{"location":"implementing/","page":"Implementing the AbstractTrees API","title":"Implementing the AbstractTrees API","text":"print_tree calls the AbstractTrees.printnode function to display the representation of each node in the tree. The default implementation uses the output of Base.show (with an appropriate IOContext). You may override this to customize how your tree is printed:","category":"page"},{"location":"implementing/","page":"Implementing the AbstractTrees API","title":"Implementing the AbstractTrees API","text":"AbstractTrees.printnode(io::IO, node::MyNode) = print(io, \"MyNode($(node.data))\")\n\nprint_tree(tree)\n\n# output\n\nMyNode(1)\n├─ MyNode(2)\n│  ├─ MyNode(3)\n│  └─ MyNode(4)\n├─ MyNode(5)\n└─ MyNode(6)\n   └─ MyNode(7)","category":"page"},{"location":"implementing/","page":"Implementing the AbstractTrees API","title":"Implementing the AbstractTrees API","text":"Typical implementations will print only a single line, but print_tree should maintain proper formatting and indentation with multi-line output.","category":"page"},{"location":"implementing/#Additional-Examples","page":"Implementing the AbstractTrees API","title":"Additional Examples","text":"","category":"section"},{"location":"implementing/","page":"Implementing the AbstractTrees API","title":"Implementing the AbstractTrees API","text":"The examples folder contains a number of usage examples of varying complexity.","category":"page"},{"location":"#AbstractTrees.jl","page":"AbstractTrees.jl","title":"AbstractTrees.jl","text":"","category":"section"},{"location":"","page":"AbstractTrees.jl","title":"AbstractTrees.jl","text":"Trees come in many shapes and sizes. For some, the tree structure is explicit, for some implicit. Some store links to their children and parents. Others don't. Some have stored or easily computable children, for others (e.g. file system trees) accessing the list of children can be quite expensive. As such, providing (efficient) abstractions over these various kinds of data structures is no easy task.","category":"page"},{"location":"","page":"AbstractTrees.jl","title":"AbstractTrees.jl","text":"This package provides common interfaces for packages working with tree-like data structures. It does not itself provide any particular tree structure, but is designed to be easy to integrate. For most tree implimentations, the tree interface should be declarable little or no additional code.","category":"page"},{"location":"","page":"AbstractTrees.jl","title":"AbstractTrees.jl","text":"The most important interface in this library is the children method that allows any arbitrary data structures to take advantage of any generic tree algorithm in this package (or other packages compatible with this package).","category":"page"},{"location":"#Package-overview","page":"AbstractTrees.jl","title":"Package overview","text":"","category":"section"},{"location":"","page":"AbstractTrees.jl","title":"AbstractTrees.jl","text":"A common interface to arbitrary tree-like data structures, primarily through the children function.\nPretty-printing trees with print_tree.\nTree traversal utilities:\nLeaves is an iterator to visit the leaves of a tree in order.\nPostOrderDFS is a depth-first search (i.e. will visit node's children before it's lexicographically following siblings) that guarantees to visit children before their parents.\nPreOrderDFS is same as PostOrderDFS but visits parents before their children.\nStatelessBFS iterates over a tree level-by-level, but does not keep state (causing this to be O(n^2), but able to handle changing trees).\nTree is a simple wrapper around an arbitrary object that allows tree-indexing into that object (i.e. indexing with collections of indices specifying the child index at every level).\nShadowTree is a tree object that combines two trees of equal structure into a single tree (indexing always produces another ShadowTree, but setindex! with tuples is allowed). Useful for adding annotation nodes to other trees without modifying that tree structure itself.\ntreemap maps each node of a tree to obtain a new tree.\ntreemap! maps each node of a tree in place.","category":"page"}]
}
